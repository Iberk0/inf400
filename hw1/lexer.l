
%option noyywrap

%{
// https://stackoverflow.com/questions/9611682/flexlexer-support-for-unicode/9617585#9617585
#include "parser.hpp"
#include "main.h"
#include <kiraz/token/Literal.h>
#include <kiraz/token/Operator.h>
static auto &colno = Token::colno;
using namespace token;
extern std::shared_ptr<Token> curtoken;
%}

%option yylineno

%%
"func"      {colno += yyleng; curtoken = Token::New<FuncKeyword>(); return KW_FUNC;}
"let"       {colno += yyleng; curtoken = Token::New<LetKeyword>(); return KW_LET;}
":"         {colno += yyleng; curtoken = Token::New<Colon>(); return COLON;}
","         {colno += yyleng; curtoken = Token::New<OpComma>(); return OP_COMMA;}
"="         {colno += yyleng; curtoken = Token::New<OpAssign>(); return OP_ASSIGN;}
"{"         {colno += yyleng; curtoken = Token::New<OpLbrace>(); return OP_LBRACE;}
"}"         {colno += yyleng; curtoken = Token::New<OpRbrace>(); return OP_RBRACE;}
";"         {colno += yyleng; curtoken = Token::New<OpScolon>(); return OP_SCOLON;}

[a-zA-Z_][a-zA-Z0-9_]*  {colno += yyleng; curtoken = Token::New<Identifier>(yytext); return IDENTIFIER;}
[A-Z][a-zA-Z0-9_]*  {colno += yyleng; curtoken = Token::New<TypeAnnot>(yytext); return TYPE_ANNOT;}

[0-9]+      {colno += yyleng; curtoken = Token::New<Integer>(10,yytext); return L_INTEGER;}

"+"         {colno += yyleng; curtoken = Token::New<OpPlus>(); return OP_PLUS;}
"-"         {colno += yyleng; curtoken = Token::New<OpMinus>(); return OP_MINUS;}
"*"         {colno += yyleng; curtoken = Token::New<OpMult>(); return OP_MULT;}
"/"         {colno += yyleng; curtoken = Token::New<OpDivF>(); return OP_DIVF;}
"("         {colno += yyleng; curtoken = Token::New<OpLparen>(); return OP_LPAREN;}
")"         {colno += yyleng; curtoken = Token::New<OpRparen>(); return OP_RPAREN;}

[ \n\t]+    {colno += yyleng;}
.           {colno += yyleng; curtoken = Token::New<Rejected>(); return YYUNDEF; }
